import{buildOr as n,buildAnd as t}from"@ucast/mongo2js";function r(n){return Array.isArray(n)?n:[n]}function e(n,t,r){let e=n;let o=t;if(-1!==t.indexOf(".")){const r=t.split(".");o=r.pop();e=r.reduce(((n,t)=>{n[t]=n[t]||{};return n[t]}),n)}e[o]=r}function o(n,t,r,e){const o={};const c=n.rulesFor(t,r);for(let n=0;n<c.length;n++){const t=c[n];const r=t.inverted?"$and":"$or";if(!t.conditions)if(t.inverted)break;else{delete o[r];return o}else{o[r]=o[r]||[];o[r].push(e(t))}}return o.$or?o:null}function c(n){if(!n.ast)throw new Error(`Ability rule "${JSON.stringify(n)}" does not have "ast" property. So, cannot be used to generate AST`);return n.ast}function u(r,e,u){const i=o(r,e,u,c);if(null===i)return null;if(!i.$and)return i.$or?n(i.$or):t([]);if(i.$or)i.$and.push(n(i.$or));return t(i.$and)}function i(n,t,r){return n.rulesFor(t,r).reduce(((n,t)=>{if(t.inverted||!t.conditions)return n;return Object.keys(t.conditions).reduce(((n,r)=>{const o=t.conditions[r];if(!o||o.constructor!==Object)e(n,r,o);return n}),n)}),{})}function f(n,t,r,e){const o=n.detectSubjectType(r);const c=n.possibleRulesFor(t,o);const u=new Set;const i=u.delete.bind(u);const f=u.add.bind(u);let s=c.length;while(s--){const n=c[s];if(n.matchesConditions(r)){const t=n.inverted?i:f;e.fieldsFrom(n).forEach(t)}}return Array.from(u)}const s=n=>Array.isArray(n)?n.join(","):n;function l(n,t){return n.map((n=>{const e=[s(n.action||n.actions),"function"===typeof t?r(n.subject).map(t).join(","):s(n.subject),n.conditions||0,n.inverted?1:0,n.fields?s(n.fields):0,n.reason||""];while(!e[e.length-1])e.pop();return e}))}function a(n,t){return n.map((([n,r,e,o,c,u])=>{const i=r.split(",");const f={inverted:!!o,action:n.split(","),subject:"function"===typeof t?i.map(t):i};if(e)f.conditions=e;if(c)f.fields=c.split(",");if(u)f.reason=u;return f}))}export{l as packRules,f as permittedFieldsOf,u as rulesToAST,i as rulesToFields,o as rulesToQuery,a as unpackRules};
//# sourceMappingURL=extra.mjs.map
