import{ref as t,inject as i,provide as n,defineComponent as r}from"vue";import{PureAbility as e}from"@casl/ability";function reactiveAbility(i){if(i.hasOwnProperty("possibleRulesFor"))return i;const n=t(true);i.on("updated",(()=>{n.value=!n.value}));const r=i.possibleRulesFor.bind(i);i.possibleRulesFor=(t,i)=>{n.value=n.value;return r(t,i)};i.can=i.can.bind(i);i.cannot=i.cannot.bind(i);return i}const o=Symbol("ability");function useAbility(){const t=i(o);if(!t)throw new Error("Cannot inject Ability instance because it was not provided");return t}function provideAbility(t){n(o,reactiveAbility(t))}function s(t){if("a"in t)return"a";if("this"in t)return"this";if("an"in t)return"an";return""}const u=r({name:"Can",props:{I:String,do:String,a:[String,Function],an:[String,Function],this:[String,Function,Object],on:[String,Function,Object],not:Boolean,passThrough:Boolean,field:String},setup(t,{slots:i}){const n=t;let r="do";let e="on";if(!(r in t)){r="I";e=s(t)}if(!n[r])throw new Error("Neither `I` nor `do` prop was passed in <Can>");if(!i.default)throw new Error("Expects to receive default slot");const o=useAbility();return()=>{const s=o.can(n[r],n[e],n.field);const u=t.not?!s:s;if(!t.passThrough)return u?i.default():null;return i.default({allowed:u,ability:o})}}});function a(t,i,n){if(!i||!(i instanceof e))throw new Error("Please provide an Ability instance to abilitiesPlugin plugin");t.provide(o,reactiveAbility(i));if(n&&n.useGlobalProperties){t.config.globalProperties.$ability=i;t.config.globalProperties.$can=i.can.bind(i)}}export{o as ABILITY_TOKEN,u as Can,a as abilitiesPlugin,provideAbility,useAbility};
//# sourceMappingURL=index.mjs.map
