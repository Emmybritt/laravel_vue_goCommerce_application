import{ref as i,inject as n,provide as r,defineComponent as t}from"vue";import{PureAbility as e}from"@casl/ability";function reactiveAbility(n){if(n.hasOwnProperty("possibleRulesFor"))return n;var r=i(true);n.on("updated",(function(){r.value=!r.value}));var t=n.possibleRulesFor.bind(n);n.possibleRulesFor=function(i,n){r.value=r.value;return t(i,n)};n.can=n.can.bind(n);n.cannot=n.cannot.bind(n);return n}var o=Symbol("ability");function useAbility(){var i=n(o);if(!i)throw new Error("Cannot inject Ability instance because it was not provided");return i}function provideAbility(i){r(o,reactiveAbility(i))}function a(i){if("a"in i)return"a";if("this"in i)return"this";if("an"in i)return"an";return""}var u=t({name:"Can",props:{I:String,do:String,a:[String,Function],an:[String,Function],this:[String,Function,Object],on:[String,Function,Object],not:Boolean,passThrough:Boolean,field:String},setup:function i(n,r){var t=r.slots;var e=n;var o="do";var u="on";if(!(o in n)){o="I";u=a(n)}if(!e[o])throw new Error("Neither `I` nor `do` prop was passed in <Can>");if(!t.default)throw new Error("Expects to receive default slot");var l=useAbility();return function(){var i=l.can(e[o],e[u],e.field);var r=n.not?!i:i;if(!n.passThrough)return r?t.default():null;return t.default({allowed:r,ability:l})}}});function l(i,n,r){if(!n||!(n instanceof e))throw new Error("Please provide an Ability instance to abilitiesPlugin plugin");i.provide(o,reactiveAbility(n));if(r&&r.useGlobalProperties){i.config.globalProperties.$ability=n;i.config.globalProperties.$can=n.can.bind(n)}}export{o as ABILITY_TOKEN,u as Can,l as abilitiesPlugin,provideAbility,useAbility};
//# sourceMappingURL=index.js.map
